<!DOCTYPE html>
<html>

<head>
	<title>WebGPU Sandbox</title>
</head>

<body>
	<main id="main"></main>

	<script id="shaders" type="text/wgsl">
		struct Camera {
			position: vec3f,
			direction: vec3f
		};

		@group(0) @binding(0) var<uniform> ambient: vec3f;
		@group(1) @binding(0) var<uniform> view: mat4x4f;
		@group(1) @binding(1) var<uniform> proj: mat4x4f;
		@group(1) @binding(2) var<uniform> viewProj: mat4x4f;
		@group(1) @binding(3) var<uniform> camera: Camera;
		@group(2) @binding(0) var<uniform> model: mat4x4f;

		struct VertexOut {
			@builtin(position) position: vec4f,
			@location(0) normal: vec4f,
			@location(1) color: vec3f
		}

		@vertex
		fn vertexShader(
			@location(0) position: vec3f,
			@location(1) normal: vec3f,
			@location(2) color: vec3f
		) -> VertexOut {
			return VertexOut(
				vec4f(position, 1) * model * viewProj,
				// TODO Transform matrix for surface normals
				// vec4f(normal, 1) * model * view,
				vec4f(normal, 1),
				color
			);
		}

		const lightPos = vec3f(-6, 6, 0);
		const diffuse = 1;
		const specular = 1;
		const shininess = 1;

		@fragment
		fn fragmentShader(
			@builtin(position) position: vec4f,
			@location(0) normal: vec4f,
			@location(1) color: vec3f
		) -> @location(0) vec4f {
			var lightDir = normalize(position.xyz - lightPos);
			var viewDir = normalize(position.xyz - camera.position);

			// Angle between surface normal and light direction
			var normalDir = normalize(normal.xyz);
			var lightNormalAngle = max(dot(lightDir, normalDir), 0);

			// Reflection
			var reflectionDir = reflect(lightDir, normalDir);
			var reflectionViewAngle = max(dot(reflectionDir, viewDir), 0);

			// Phong
			var phong = diffuse * lightNormalAngle * ambient * color
				+ specular * pow(reflectionViewAngle, shininess) * ambient * color;

			return vec4f(phong, 1);
			// return vec4f(color, 1);
		}
	</script>

	<script src="dist/index.js"></script>

</body>

</html>